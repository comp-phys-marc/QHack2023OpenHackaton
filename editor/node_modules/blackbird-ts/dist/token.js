"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.notNestedParam = exports.typeName = exports.inverseParamLookup = exports.lookupType = exports.lookup = exports.notParam = exports.Token = void 0;
var Token;
(function (Token) {
    Token[Token["Plus"] = 0] = "Plus";
    Token[Token["Minus"] = 1] = "Minus";
    Token[Token["Times"] = 2] = "Times";
    Token[Token["Divide"] = 3] = "Divide";
    Token[Token["Pwr"] = 4] = "Pwr";
    Token[Token["Assign"] = 5] = "Assign";
    Token[Token["Int"] = 6] = "Int";
    Token[Token["Float"] = 7] = "Float";
    Token[Token["Complex"] = 8] = "Complex";
    Token[Token["Str"] = 9] = "Str";
    Token[Token["Bool"] = 10] = "Bool";
    Token[Token["Sequence"] = 11] = "Sequence";
    Token[Token["Pi"] = 12] = "Pi";
    Token[Token["Newline"] = 13] = "Newline";
    Token[Token["Tab"] = 14] = "Tab";
    Token[Token["Space"] = 15] = "Space";
    Token[Token["Progname"] = 16] = "Progname";
    Token[Token["Version"] = 17] = "Version";
    Token[Token["Target"] = 18] = "Target";
    Token[Token["Include"] = 19] = "Include";
    Token[Token["Sqrt"] = 20] = "Sqrt";
    Token[Token["Sin"] = 21] = "Sin";
    Token[Token["Cos"] = 22] = "Cos";
    Token[Token["Tan"] = 23] = "Tan";
    Token[Token["ArcSin"] = 24] = "ArcSin";
    Token[Token["ArcCos"] = 25] = "ArcCos";
    Token[Token["ArcTan"] = 26] = "ArcTan";
    Token[Token["Sinh"] = 27] = "Sinh";
    Token[Token["Cosh"] = 28] = "Cosh";
    Token[Token["Tanh"] = 29] = "Tanh";
    Token[Token["ArcSinh"] = 30] = "ArcSinh";
    Token[Token["ArcCosh"] = 31] = "ArcCosh";
    Token[Token["ArcTanh"] = 32] = "ArcTanh";
    Token[Token["Exp"] = 33] = "Exp";
    Token[Token["Log"] = 34] = "Log";
    Token[Token["Period"] = 35] = "Period";
    Token[Token["Comma"] = 36] = "Comma";
    Token[Token["Colon"] = 37] = "Colon";
    Token[Token["Quote"] = 38] = "Quote";
    Token[Token["Lbrac"] = 39] = "Lbrac";
    Token[Token["Rbrac"] = 40] = "Rbrac";
    Token[Token["Lsqbrac"] = 41] = "Lsqbrac";
    Token[Token["Rsqbrac"] = 42] = "Rsqbrac";
    Token[Token["Lbrace"] = 43] = "Lbrace";
    Token[Token["Rbrace"] = 44] = "Rbrace";
    Token[Token["Apply"] = 45] = "Apply";
    Token[Token["TypeArray"] = 46] = "TypeArray";
    Token[Token["TypeFloat"] = 47] = "TypeFloat";
    Token[Token["TypeComplex"] = 48] = "TypeComplex";
    Token[Token["TypeInt"] = 49] = "TypeInt";
    Token[Token["TypeStr"] = 50] = "TypeStr";
    Token[Token["TypeBool"] = 51] = "TypeBool";
    Token[Token["TypeAny"] = 52] = "TypeAny";
    Token[Token["RegRef"] = 53] = "RegRef";
    Token[Token["Measure"] = 54] = "Measure";
    Token[Token["Name"] = 55] = "Name";
    Token[Token["Device"] = 56] = "Device";
    Token[Token["Comment"] = 57] = "Comment";
    Token[Token["Identifier"] = 58] = "Identifier";
    Token[Token["String"] = 59] = "String";
    Token[Token["EndOfFile"] = 60] = "EndOfFile";
    Token[Token["Illegal"] = 61] = "Illegal";
    Token[Token["True"] = 62] = "True";
    Token[Token["False"] = 63] = "False";
})(Token || (Token = {}));
exports.Token = Token;
var typeLookupMap = {
    'array': Token.TypeArray,
    'float': Token.TypeFloat,
    'complex': Token.TypeComplex,
    'int': Token.TypeInt,
    'str': Token.TypeStr,
    'bool': Token.TypeBool
};
var nestedParamLookupMap = {
    'sqrt': Token.Sqrt,
    'sin': Token.Sin,
    'cos': Token.Cos,
    'tan': Token.Tan,
    'arcsin': Token.ArcSin,
    'arccos': Token.ArcCos,
    'arctan': Token.ArcTan,
    'sinh': Token.Sinh,
    'cosh': Token.Cosh,
    'tanh': Token.Tanh,
    'arcsinh': Token.ArcSinh,
    'arccosh': Token.ArcCosh,
    'arctanh': Token.ArcTanh,
    'exp': Token.Exp,
    'log': Token.Log
};
var paramLookupMap = __assign(__assign({}, nestedParamLookupMap), { '+': Token.Plus, '-': Token.Minus, '*': Token.Times, '/': Token.Divide, '**': Token.Pwr, '=': Token.Assign, 'pi': Token.Pi, '.': Token.Period, 'True': Token.True, 'False': Token.False });
var lookupMap = __assign(__assign(__assign({}, typeLookupMap), paramLookupMap), { 'name': Token.Name, 'version': Token.Version, 'target': Token.Target, 'include': Token.Include, ',': Token.Comma, ':': Token.Colon, '"': Token.Quote, '(': Token.Lbrac, ')': Token.Rbrac, '[': Token.Lsqbrac, ']': Token.Rsqbrac, '{': Token.Lbrace, '}': Token.Rbrace, '|': Token.Apply });
/**
 * Returns the token that represents a given type string.
 * @param ident - The type string.
 * @return The corresponding token.
 */
function lookupType(ident) {
    if (ident in typeLookupMap) {
        return typeLookupMap[ident];
    }
    else {
        return Token.Illegal;
    }
}
exports.lookupType = lookupType;
/**
 * Returns the token that represents a given string.
 * @param ident - The string.
 * @return The corresponding token.
 */
function lookup(ident) {
    return ident in lookupMap ? lookupMap[ident] : Token.Identifier;
}
exports.lookup = lookup;
/**
 * Returns the string representation of a parameter token.
 * @param tokens - The token.
 * @return The string representation of the token.
 */
function inverseParamLookup(token) {
    return Object.keys(paramLookupMap).find(function (ident) { return paramLookupMap[ident] == token; });
}
exports.inverseParamLookup = inverseParamLookup;
/**
 * Determines whether a token denotes a parameter.
 * @param tokens - The token.
 * @return Whether the token does NOT denote a parameter.
 */
function notParam(token) {
    return (Object.keys(paramLookupMap).map(function (key) {
        return paramLookupMap[key];
    }).indexOf(token) == -1) && token != Token.Int && token
        != Token.Float && token != Token.Complex && token != Token.Identifier;
}
exports.notParam = notParam;
/**
 * Determines whether a token denotes a nested parameter.
 * @param tokens - The token.
 * @return Whether the token does NOT denote a nested parameter.
 */
function notNestedParam(token) {
    return (Object.keys(nestedParamLookupMap).map(function (key) {
        return nestedParamLookupMap[key];
    }).indexOf(token) == -1);
}
exports.notNestedParam = notNestedParam;
/**
 * Returns the string representation of a type.
 * @param tokens - The typeâ€™s corresponding token.
 * @return The string representation of the type.
 */
function typeName(type) {
    var strType;
    switch (type) {
        case Token.Int:
            strType = 'Int';
        case Token.Float:
            strType = 'Float';
        case Token.Str:
            strType = 'Str';
        case Token.Bool:
            strType = 'Bool';
        case Token.Complex:
            strType = 'Complex';
    }
    return strType;
}
exports.typeName = typeName;
