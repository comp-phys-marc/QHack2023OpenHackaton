"use strict";
exports.__esModule = true;
var token_1 = require("./token");
var complex_1 = require("./complex");
/**
 * Returns whether a given character could be an element of a numeric value.
 * @param c - The character.
 * @return Whether the character is numeric.
 */
function isNumeric(c) {
    return (c == '.') || (c == 'e') || (c == '+') || (c == '-') || (c == 'j') ||
        !isNaN(parseInt(c));
}
/**
 * Returns whether a given character is a letter.
 * @param c - The character.
 * @return Whether the character is a letter.
 */
function isLetter(c) {
    if (c.match(/[a-z]/i)) {
        return true;
    }
    return false;
}
/**
 * Returns whether a given string includes the substring ’Measure’.
 * @param s - The string.
 * @return Whether the string includes the substring.
 */
function isMeasurement(s) {
    return (s.indexOf('Measure') != -1);
}
/**
 * Returns whether a given character is alphanumeric.
 * @param c - The character.
 * @return Whether the character is alphanumeric.
 */
function isAlpha(c) {
    if (c.match(/^[0-9a-zA-Z]+$/)) {
        return true;
    }
    return false;
}
/**
 * Returns whether a given character is a newline character.
 * @param c - The character.
 * @return Whether the character is a newline.
 */
function isNewline(c) {
    if (c.match(/\n|\r(?!\n)|\u2028|\u2029|\r\n/g)) {
        return true;
    }
    return false;
}
/** Class representing a lexer. */
var Lexer = /** @class */ (function () {
    /**
     * Creates a lexer.
     * @param input - The string to lex.
     * @param cursor - The starting cursor position.
     */
    function Lexer(input, cursor) {
        var _this = this;
        if (cursor === void 0) { cursor = 0; }
        /**
         * Determines whether the next character to process equals a given character.
         * @param c - The given character.
         * @return Whether the next character equals the given character.
         */
        this.peekEq = function (c) { return (_this.peek() == c); };
        /**
         * Reads a character without advancing the cursor.
         * @param index - Optional peek position offset.
         */
        this.peek = function (index) {
            if (index === void 0) { index = 0; }
            return _this.input[_this.cursor + index];
        };
        /**
         * Reads a string literal.
         * @param terminator - The literal’s termination character.
         * @return The literal as a string.
         */
        this.readStringLiteral = function (terminator) {
            var lit = '';
            var char = '';
            while (!(terminator == char)) {
                char = _this.readChar();
                lit += char;
            }
            return lit;
        };
        this.input = input;
        this.cursor = cursor;
    }
    /**
     * Calling this method lexes the code represented by the provided string.
     * @return An array of tokens and their corresponding values.
     */
    Lexer.prototype.lex = function () {
        var tokens = [];
        var token;
        while (this.cursor < this.input.length) {
            var empty = true;
            var i = 0;
            while (empty) {
                if (this.peek(i) && isNewline(this.peek(i))) {
                    tokens.push([token_1.Token.Newline]);
                    i++;
                }
                else {
                    empty = false;
                }
            }
            token = this.nextToken();
            if (token) {
                tokens.push(token);
            }
        }
        return tokens;
    };
    /**
     * Reads a character and advances the cursor.
     * @param num - Optional cursor position modifier.
     */
    Lexer.prototype.readChar = function (num) {
        if (num === void 0) { num = 1; }
        this.cursor += num;
        return this.input[this.cursor - num];
    };
    /**
     * Reads a comment.
     * @return The comment string.
     */
    Lexer.prototype.readComment = function () {
        var char = this.peek();
        var comment = '';
        while (!isNewline(char)) {
            this.readChar();
            comment += char;
            char = this.peek();
        }
        return comment;
    };
    /**
     * Reads a numeric value.
     * @return The numeric value as a string.
     */
    Lexer.prototype.readNumeric = function () {
        var num = '';
        while (isNumeric(this.peek())) {
            num += this.readChar();
        }
        return num;
    };
    /**
     * Reads an alphanumeric value.
     * @return The alphanumeric value as a string.
     */
    Lexer.prototype.readAlpha = function () {
        var alpha = '';
        while (isAlpha(this.peek())) {
            alpha += this.readChar();
        }
        return alpha;
    };
    /**
     * Advances the cusor past the next block of whitespace.
     */
    Lexer.prototype.skipWhitespace = function () {
        while (' \t\n\r\v'.indexOf(this.peek()) > -1) {
            this.cursor += 1;
        }
    };
    /**
     * Lexes the next token.
     * @return The next token and its corresponding value.
     */
    Lexer.prototype.nextToken = function () {
        this.skipWhitespace();
        if (this.cursor == this.input.length) {
            return [token_1.Token.EndOfFile];
        }
        var char = this.peek();
        this.readChar();
        if (char == '*') {
            if (this.peek() == '*') {
                this.readChar();
                return [token_1.Token.Pwr];
            }
            return [token_1.Token.Times];
        }
        if (char == '#') {
            return [token_1.Token.Comment, this.readComment()];
        }
        if (char == '\"') {
            var stringLiteral = char + this.readStringLiteral('\"');
            return [token_1.Token.String, new String(stringLiteral)];
        }
        if (char == '\’') {
            return [token_1.Token.Illegal];
        }
        if (isLetter(char)) {
            var literal = char + this.readAlpha();
            var look = token_1.lookup(literal);
            if (look == token_1.Token.Name
                || look == token_1.Token.Device
                || look == token_1.Token.Include
                || look == token_1.Token.Target) {
                this.skipWhitespace();
                return [look, this.readAlpha()];
            }
            else if (look == token_1.Token.Version) {
                this.skipWhitespace();
                return [look, this.readNumeric()];
            }
            else if (look != token_1.Token.Identifier) {
                return [look];
            }
            else {
                if (isMeasurement(literal)) {
                    return [token_1.Token.Measure, literal.toString()];
                }
                else {
                    return [token_1.Token.Identifier, literal.toString()];
                }
            }
        }
        else if (!isNumeric(char)) {
            var look = token_1.lookup(char);
            if (look != token_1.Token.Identifier) {
                return [token_1.lookup(char)];
            }
            else {
                return [token_1.Token.Illegal];
            }
        }
        else {
            var num = char + this.readNumeric();
            if (num.indexOf('j') != -1) {
                return [token_1.Token.Complex, complex_1.parseComplex(num)];
            }
            else if (num.indexOf('.') != -1) {
                return [token_1.Token.Float, parseFloat(num)];
            }
            else {
                return [token_1.Token.Int, parseFloat(num)];
            }
        }
    };
    return Lexer;
}());
exports["default"] = Lexer;
