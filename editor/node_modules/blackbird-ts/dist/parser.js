"use strict";
exports.__esModule = true;
var token_1 = require("./token");
var errors_1 = require("./errors");
var ast_1 = require("./ast");
var complex_1 = require("./complex");
/** Class representing a token parser. */
var Parser = /** @class */ (function () {
    /**
     * Creates a parser.
     * @param tokens - Tokens to parse.
     */
    function Parser(tokens) {
        this.tokens = tokens;
        this.operators = [
            'Xgate',
            'Zgate',
            'Dgate',
            'Sgate',
            'Rgate',
            'Pgate',
            'Vgate',
            'Kgate',
            'Fouriergate',
            'CXgate',
            'CZgate',
            'CKgate',
            'BSgate',
            'S2gate',
            'Interferometer',
            'GaussianTransform',
            'Gaussian'
        ];
        this.prepStates = [
            'Fock',
            'Coherent',
            'Squeezed',
            'Vac',
            'Thermal',
            'DisplacedSqueezed',
            'Catstate'
        ];
    }
    /**
     * Calling this method parses the code represented by the provided tokens.
     * @return The abstract syntax tree.
     */
    Parser.prototype.parse = function () {
        var ast = [];
        var i = 0;
        while (i < (this.tokens.length - 1)) {
            var nodes = this.parseNode(this.tokens.slice(i));
            ast = ast.concat(nodes ? nodes : []);
            if (this.tokens[i][0] == token_1.Token.TypeArray || this.tokens[i + 1][0] ==
                token_1.Token.TypeArray) {
                while (!(this.matchNext(this.tokens.slice(i), [token_1.Token.Newline,
                    token_1.Token.Newline]))) {
                    i++;
                }
                i++;
            }
            else {
                while (!(this.tokens[i] == undefined) &&
                    !(this.matchNext(this.tokens.slice(i), [token_1.Token.EndOfFile])) &&
                    !(this.matchNext(this.tokens.slice(i), [token_1.Token.Newline]))) {
                    i++;
                }
            }
            i++;
        }
        return ast;
    };
    /**
     * Delegates the parsing of the next set of tokens to the appropriate method.
     * @param tokens - Remaining tokens to parse.
     * @param allowVariables - Whether encountered identifiers should be consider
        variable initializations or references.
    * @return A set of AST nodes.
    */
    Parser.prototype.parseNode = function (tokens, allowVariables) {
        if (allowVariables === void 0) { allowVariables = false; }
        var token = tokens[0];
        switch (token[0]) {
            case token_1.Token.True:
                return [new ast_1.Bool(true)];
            case token_1.Token.False:
                return [new ast_1.Bool(false)];
            case token_1.Token.Name:
                return [new ast_1.Name(token[1].toString())];
            case token_1.Token.Version:
                return [new ast_1.Version(token[1].toString())];
            case token_1.Token.Target:
                return [new ast_1.Target(token[1].toString(), this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Device:
                return [new ast_1.Device(token[1].toString())];
            case token_1.Token.Measure:
                return [this.measure(tokens)];
            case token_1.Token.Identifier:
                if (!allowVariables) {
                    if (this.operators.includes(token[1].toString()) ||
                        this.prepStates.includes(token[1].toString())) {
                        return [this.application(tokens)];
                    }
                    else {
                        throw errors_1.BadOperatorError;
                    }
                }
                else {
                    return [new ast_1.Variable(token[1].toString())];
                }
            case token_1.Token.Include:
                this.operators.push(token[1].toString());
                return [new ast_1.Include(token[1].toString())];
            case token_1.Token.Int:
                return [new ast_1.Int(Number(tokens[0][1]))];
            case token_1.Token.Float:
                return [new ast_1.Float(Number(tokens[0][1]))];
            case token_1.Token.Complex:
                return [new ast_1.Comp(complex_1.parseComplex(tokens[0][1].toString()))];
            case token_1.Token.TypeArray:
                return [this.array(tokens.slice(1))];
            case token_1.Token.TypeInt:
                return [this.int(tokens.slice(1))];
            case token_1.Token.TypeFloat:
                return [this.float(tokens.slice(1))];
            case token_1.Token.TypeBool:
                return [this.bool(tokens.slice(1))];
            case token_1.Token.TypeStr:
                return [this.str(tokens.slice(1))];
            case token_1.Token.TypeComplex:
                return [this.complex(tokens.slice(1))];
            case token_1.Token.Pwr:
                return [new ast_1.Power()];
            case token_1.Token.Divide:
                return [new ast_1.Divide()];
            case token_1.Token.Times:
                return [new ast_1.Times()];
            case token_1.Token.Plus:
                return [new ast_1.Plus()];
            case token_1.Token.Minus:
                return [new ast_1.Minus()];
            case token_1.Token.Pi:
                return [new ast_1.Pi()];
            case token_1.Token.Assign:
                return [new ast_1.Equals()];
            case token_1.Token.String:
                return [new ast_1.Str(token[1])];
            case token_1.Token.Log:
                return [new ast_1.Log(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Sin:
                return [new ast_1.Sin(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Cos:
                return [new ast_1.Cos(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Exp:
                return [new ast_1.Exp(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Sqrt:
                return [new ast_1.Sqrt(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Tan:
                return [new ast_1.Tan(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.ArcSin:
                return [new ast_1.ArcSin(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.ArcCos:
                return [new ast_1.ArcCos(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.ArcTan:
                return [new ast_1.ArcTan(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.ArcSinh:
                return [new ast_1.ArcSinh(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.ArcCosh:
                return [new ast_1.ArcCosh(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.ArcTanh:
                return [new ast_1.ArcTanh(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Sinh:
                return [new ast_1.Sinh(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Cosh:
                return [new ast_1.Cosh(this.matchParamList(tokens.slice(1)))];
            case token_1.Token.Tanh:
                return [new ast_1.Tanh(this.matchParamList(tokens.slice(1)))];
        }
    };
    /**
     * Parses a logical and mathematical expression.
     * @param tokens - Expression tokens to parse.
     * @return A parsed expression.
     */
    Parser.prototype.parseExpression = function (tokens) {
        var elements = [];
        while (tokens.length > 0) {
            if (token_1.notNestedParam(tokens[0][0])) {
                var node = this.parseNode(tokens, true);
                if (node != undefined) {
                    for (var i in node) {
                        elements.push(node[i]);
                    }
                }
                tokens = tokens.slice(1);
            }
            else {
                var node = this.parseNode(tokens, true);
                if (node != undefined) {
                    for (var i in node) {
                        elements.push(node[i]);
                    }
                }
                while (!this.matchNext(tokens, [token_1.Token.Rbrac]) && tokens.length > 0) {
                    tokens = tokens.slice(1);
                }
                tokens = tokens.slice(1);
            }
        }
        return new ast_1.Expression(elements);
    };
    /**
     * Parses an integer variable declaration/initialization.
     * @param tokens - Tokens to parse.
     * @return The resulting AST node representing the integer.
     */
    Parser.prototype.int = function (tokens) {
        var name;
        var val;
        if (this.matchNext(tokens, [token_1.Token.Identifier])) {
            name = tokens[0][1].toString();
            tokens = tokens.slice(1);
            if (this.matchNext(tokens, [token_1.Token.Assign])) {
                tokens = tokens.slice(1);
                var i = 0;
                var paramTokens = [];
                while (tokens[i] != undefined && !this.matchNext(tokens.slice(i), [token_1.Token.Newline])) {
                    paramTokens.push(tokens[i]);
                    i++;
                }
                return new ast_1.Int(this.parseExpression(paramTokens), name);
            }
        }
        else if (this.matchNext(tokens, [token_1.Token.TypeArray])) {
            val = this.array(tokens.slice(1), token_1.Token.Int);
            return val;
        }
        throw errors_1.BadIntError;
    };
    /**
     * Parses a float variable declaration/initialization.
     * @param tokens - Tokens to parse.
     * @return The resulting AST node representing the float.
     */
    Parser.prototype.float = function (tokens) {
        var name;
        var val;
        if (this.matchNext(tokens, [token_1.Token.Identifier])) {
            name = tokens[0][1].toString();
            tokens = tokens.slice(1);
            if (this.matchNext(tokens, [token_1.Token.Assign])) {
                tokens = tokens.slice(1);
                var i = 0;
                var paramTokens = [];
                while (tokens[i] != undefined && !this.matchNext(tokens.slice(i), [token_1.Token.Newline])) {
                    paramTokens.push(tokens[i]);
                    i++;
                }
                return new ast_1.Float(this.parseExpression(paramTokens), name);
            }
        }
        else if (this.matchNext(tokens, [token_1.Token.TypeArray])) {
            val = this.array(tokens.slice(1), token_1.Token.Float);
            return val;
        }
        throw errors_1.BadFloatError;
    };
    /**
     * Parses a boolean variable declaration/initialization.
     * @param tokens - Tokens to parse.
     * @return The resulting AST node representing the boolean.
     */
    Parser.prototype.bool = function (tokens) {
        var name;
        var val;
        if (this.matchNext(tokens, [token_1.Token.Identifier])) {
            name = tokens[0][1].toString();
            tokens = tokens.slice(1);
            if (this.matchNext(tokens, [token_1.Token.Assign])) {
                tokens = tokens.slice(1);
                var i = 0;
                var paramTokens = [];
                while (tokens[i] != undefined && !this.matchNext(tokens.slice(i), [token_1.Token.Newline])) {
                    paramTokens.push(tokens[i]);
                    i++;
                }
                return new ast_1.Bool(this.parseExpression(paramTokens), name);
            }
        }
        else if (this.matchNext(tokens, [token_1.Token.TypeArray])) {
            val = this.array(tokens.slice(1), token_1.Token.Bool);
            return val;
        }
        throw errors_1.BadBoolError;
    };
    /**
     * Parses a string variable declaration/initialization.
     * @param tokens - Tokens to parse.
     * @return The resulting AST node representing the string.
     */
    Parser.prototype.str = function (tokens) {
        var name;
        var val;
        if (this.matchNext(tokens, [token_1.Token.Identifier])) {
            name = tokens[0][1].toString();
            tokens = tokens.slice(1);
            if (this.matchNext(tokens, [token_1.Token.Assign])) {
                tokens = tokens.slice(1);
                var i = 0;
                var paramTokens = [];
                while (tokens[i] != undefined && !this.matchNext(tokens.slice(i), [token_1.Token.Newline])) {
                    paramTokens.push(tokens[i]);
                    i++;
                }
                return new ast_1.Str(this.parseExpression(paramTokens), name);
            }
        }
        else if (this.matchNext(tokens, [token_1.Token.TypeArray])) {
            val = this.array(tokens.slice(1), token_1.Token.Str);
            return val;
        }
        throw errors_1.BadStrError;
    };
    /**
     * Parses a complex variable declaration/initialization.
     * @param tokens - Tokens to parse.
     * @return The resulting AST node representing the complex.
     */
    Parser.prototype.complex = function (tokens) {
        var name;
        var val;
        if (this.matchNext(tokens, [token_1.Token.Identifier])) {
            name = tokens[0][1].toString();
            tokens = tokens.slice(1);
            if (this.matchNext(tokens, [token_1.Token.Assign])) {
                tokens = tokens.slice(1);
                var i = 0;
                var paramTokens = [];
                while (tokens[i] != undefined && !this.matchNext(tokens.slice(i), [token_1.Token.Newline])) {
                    paramTokens.push(tokens[i]);
                    i++;
                }
                return new ast_1.Comp(this.parseExpression(paramTokens), name);
            }
        }
        else if (this.matchNext(tokens, [token_1.Token.TypeArray])) {
            val = this.array(tokens.slice(1), token_1.Token.Complex);
            return val;
        }
        throw errors_1.BadComplexError;
    };
    /**
     * Parses an integer value.
     * @param tokens - Tokens to parse.
     * @return An AST node representing the value.
     */
    Parser.prototype.matchInt = function (tokens) {
        var val;
        if (tokens[0][0] == token_1.Token.Int) {
            val = new ast_1.Int(Number(tokens[0][1]));
        }
        else {
            throw errors_1.BadIntError;
        }
        return val;
    };
    /**
     * Parses a list of integer values.
     * @param tokens - Tokens to parse.
     * @return An array of AST nodes representing the values.
     */
    Parser.prototype.matchIntList = function (tokens) {
        var args = [];
        var i = 0;
        while (!this.matchNext(tokens.slice(i), [token_1.Token.Rsqbrac]) &&
            !this.matchNext(tokens.slice(i), [token_1.Token.Newline])) {
            var next = this.matchInt(tokens.slice(i));
            args.push(next);
            i++;
            if (this.matchNext(tokens.slice(i), [token_1.Token.Comma])) {
                i++;
            }
        }
        return args;
    };
    /**
     * Parses an array of parameters (Float, Str, Int, Comp, Bool, etc.).
     * @param tokens - Tokens to parse.
     * @return An array of AST nodes representing the parameters.
     */
    Parser.prototype.array = function (tokens, type) {
        if (type === void 0) { type = token_1.Token.TypeAny; }
        var name;
        var vals;
        var size;
        if (this.matchNext(tokens, [token_1.Token.Identifier])) {
            name = tokens[0][1].toString();
            tokens = tokens.slice(1);
            if (this.matchNext(tokens, [token_1.Token.Lsqbrac])) {
                tokens = tokens.slice(1);
                size = this.matchIntList(tokens);
                while (!this.matchNext(tokens, [token_1.Token.Rsqbrac])) {
                    tokens = tokens.slice(1);
                }
                tokens = tokens.slice(1);
            }
            if (this.matchNext(tokens, [token_1.Token.Assign])) {
                tokens = tokens.slice(1);
            }
            else {
                throw errors_1.BadArrayError;
            }
            vals = this.matchArrList(tokens, type);
            return new ast_1.Arr(name, vals, size, token_1.typeName(type));
        }
        else {
            throw errors_1.BadArrayError;
        }
    };
    /**
     * Checks if the next tokens match those expected.
     * @param tokens - Remaining tokens to parse.
     * @param expectedTokens - Expected tokens.
     * @return Whether these is a match.
     */
    Parser.prototype.matchNext = function (tokens, expectedTokens) {
        var matches = true;
        var i = 0;
        if (tokens.length == 0) {
            return false;
        }
        while (i < expectedTokens.length) {
            if (tokens[i][0] != expectedTokens[i]) {
                matches = false;
                break;
            }
            i++;
        }
        return matches;
    };
    /**
     * Parses a measurement.
     * @param tokens - Remaining tokens to parse.
     * @return An AST node representing the measurement.
     */
    Parser.prototype.measure = function (tokens) {
        var name;
        var registers;
        var params;
        if (this.matchNext(tokens, [token_1.Token.Measure, token_1.Token.Apply])) {
            name = tokens[0][1].toString();
        }
        else if (this.matchNext(tokens, [token_1.Token.Measure, token_1.Token.Lbrac])) {
            name = tokens[0][1].toString();
            tokens = tokens.slice(2);
            params = this.matchParamList(tokens);
        }
        else {
            throw errors_1.BadMeasurementError;
        }
        while (!this.matchNext(tokens, [token_1.Token.Apply])) {
            tokens = tokens.slice(1);
        }
        tokens = tokens.slice(1);
        if (this.matchNext(tokens, [token_1.Token.Lbrac])) {
            tokens = tokens.slice(1);
            registers = this.matchIndexList(tokens);
        }
        else if (this.matchNext(tokens, [token_1.Token.Lsqbrac])) {
            tokens = tokens.slice(1);
            registers = this.matchIntList(tokens);
        }
        else {
            registers = [this.matchInt(tokens)];
        }
        return new ast_1.Measure(name, registers, params);
    };
    /**
     * Parses an application of one of hte allowed operators.
     * @param tokens - Remaining tokens to parse.
     * @return An AST node representing the operator application.
     */
    Parser.prototype.application = function (tokens) {
        var name;
        var registers;
        var params;
        if (this.matchNext(tokens, [token_1.Token.Identifier, token_1.Token.Apply])) {
            name = tokens[0][1].toString();
        }
        else if (this.matchNext(tokens, [token_1.Token.Identifier, token_1.Token.Lbrac])) {
            name = tokens[0][1].toString();
            tokens = tokens.slice(2);
            params = this.matchParamList(tokens);
        }
        else {
            throw errors_1.BadOperatorError;
        }
        while (!this.matchNext(tokens, [token_1.Token.Apply])) {
            tokens = tokens.slice(1);
        }
        tokens = tokens.slice(1);
        if (this.matchNext(tokens, [token_1.Token.Lbrac])) {
            tokens = tokens.slice(1);
            registers = this.matchIndexList(tokens);
        }
        else if (this.matchNext(tokens, [token_1.Token.Lsqbrac])) {
            tokens = tokens.slice(1);
            registers = this.matchIntList(tokens);
        }
        else {
            registers = [this.matchInt(tokens)];
        }
        return new ast_1.ApplyOperator(name, registers, params);
    };
    /**
     * Parses a parameter value.
     * @param tokens - Tokens to parse.
     * @return An AST node representing the parameter value.
     */
    Parser.prototype.matchParam = function (tokens) {
        var param;
        var paramTokens = [];
        if (!(token_1.notParam(tokens[0][0]))) {
            var i = 0;
            while (tokens[i] != undefined && !this.matchNext(tokens.slice(i), [token_1.Token.Newline]) && !this.matchNext(tokens.slice(i), [token_1.Token.Rbrac])
                && !this.matchNext(tokens.slice(i), [token_1.Token.Comma])) {
                paramTokens.push(tokens[i]);
                i++;
            }
            param = this.parseNode(paramTokens, true);
        }
        else {
            throw errors_1.BadParameterError;
        }
        return param;
    };
    /**
     * Parses a list of parameter values.
     * @param tokens - Tokens to parse.
     * @return An array of AST nodes representing the parameter values.
     */
    Parser.prototype.matchParamList = function (tokens) {
        var args = [];
        var i = 0;
        var j = 0;
        var openBrackets = 0;
        args[0] = [];
        while (tokens[j] != undefined && (openBrackets == 0 &&
            !this.matchNext(tokens.slice(j), [token_1.Token.Rbrac])) &&
            !this.matchNext(tokens.slice(j), [token_1.Token.Newline])) {
            while (!this.matchNext(tokens.slice(j), [token_1.Token.Comma]) && tokens[j] !=
                undefined && !this.matchNext(tokens.slice(j), [token_1.Token.Rbrac])) {
                if (this.matchNext(tokens.slice(j), [token_1.Token.Lbrac])) {
                    openBrackets += 1;
                    j++;
                }
                if (token_1.notParam(tokens[j][0])) {
                    throw errors_1.BadParameterError;
                }
                var next = this.matchParam(tokens.slice(j));
                if (next != undefined) {
                    for (var k in next) {
                        args[i].push(next[k]);
                    }
                }
                if (!token_1.notNestedParam(tokens[j][0])) {
                    while (!(this.matchNext(tokens.slice(j), [token_1.Token.Rbrac]))) {
                        j++;
                    }
                }
                j++;
            }
            if (this.matchNext(tokens.slice(j), [token_1.Token.Rbrac])) {
                if (openBrackets != 0) {
                    openBrackets -= 1;
                }
                else {
                    break;
                }
            }
            i++;
            j++;
            args[i] = [];
        }
        return args.filter(function (elem) { return (elem.length > 0); });
    };
    /**
     * Parses an array’s value list.
     * @param tokens - Tokens to parse.
     * @return A nested array of AST nodes representing the array elements’ values.
     */
    Parser.prototype.matchArrList = function (tokens, type) {
        if (type === void 0) { type = token_1.Token.TypeAny; }
        var elements = [];
        var i = 0;
        var j = 0;
        elements[0] = [];
        while (!this.matchNext(tokens.slice(j), [token_1.Token.Newline, token_1.Token.Newline])) {
            while (!this.matchNext(tokens.slice(j), [token_1.Token.Comma]) &&
                !this.matchNext(tokens.slice(j), [token_1.Token.Newline])) {
                if (this.matchNext(tokens.slice(j), [token_1.Token.Newline])) {
                    j++;
                }
                if (token_1.notParam(tokens[j][0])) {
                    throw errors_1.BadParameterError;
                }
                if (type != token_1.Token.TypeAny) {
                    if (!this.matchNext(tokens.slice(j), [type])) {
                        throw errors_1.BadTypeError;
                    }
                }
                var next = this.matchParam(tokens.slice(j));
                if (next != undefined) {
                    for (var k in next) {
                        elements[i].push(next[k]);
                    }
                }
                j++;
            }
            if (this.matchNext(tokens.slice(j), [token_1.Token.Newline, token_1.Token.Newline])) {
                break;
            }
            i++;
            j++;
            elements[i] = [];
        }
        return elements.filter(function (elem) { return (elem.length > 0); });
    };
    /**
     * Parses a register index.
     * @param tokens - Tokens to parse.
     * @return The index’s value.
     */
    Parser.prototype.matchIndex = function (tokens) {
        var index;
        if (this.matchNext(tokens, [token_1.Token.Lsqbrac])) {
            tokens = tokens.slice(1);
            if (this.matchNext(tokens, [token_1.Token.Int])) {
                index = Number(tokens[0][1]);
                tokens = tokens.slice(1);
            }
            else {
                throw errors_1.BadArgumentError;
            }
            if (this.matchNext(tokens, [token_1.Token.Rsqbrac])) {
                return index;
            }
            else {
                throw errors_1.BadArgumentError;
            }
        }
    };
    /**
     * Parses a list of registers.
     * @param tokens - Tokens to parse.
     * @return An array of AST nodes representing the registers.
     */
    Parser.prototype.matchIndexList = function (tokens) {
        var args = [];
        var next;
        var id;
        var j = 0;
        while (j < tokens.length && !this.matchNext(tokens.slice(j), [token_1.Token.Newline]) && !this.matchNext(tokens.slice(j), [token_1.Token.Rbrac])) {
            id = tokens[j][1].toString();
            var index = this.matchIndex(tokens.slice(j + 1));
            next = new ast_1.Register(id, index);
            args.push(next);
            if (index != undefined) {
                j += 4;
            }
            else {
                j++;
            }
            if (this.matchNext(tokens.slice(j), [token_1.Token.Comma])) {
                j++;
            }
        }
        return args;
    };
    return Parser;
}());
exports["default"] = Parser;
