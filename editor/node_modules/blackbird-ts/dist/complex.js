"use strict";
exports.__esModule = true;
exports.parseComplex = exports.Complex = void 0;
/** Class representing a complex number. */
var Complex = /** @class */ (function () {
    /**
     * Creates a complex number.
     * @param real - The real component.
     * @param imaginary - The imaginary component.
     */
    function Complex(real, imaginary) {
        this.real = real;
        this.imaginary = imaginary;
    }
    /**
     * Returns the complex number's string representation.
     * @return The complex number's string representation.
     */
    Complex.prototype.toString = function () {
        if (this.real != undefined && this.imaginary != undefined) {
            if (this.imaginary < 0) {
                return this.real.toString() + this.imaginary.toString() + 'j';
            }
            else {
                return this.real.toString() + '+' + this.imaginary.toString() + 'j';
            }
        }
        else if (this.real != undefined) {
            return this.real.toString();
        }
        else if (this.imaginary != undefined) {
            return this.imaginary.toString() + 'j';
        }
    };
    return Complex;
}());
exports.Complex = Complex;
/**
 * Parses a complex number's string representation.
 * @param val - The number's string representation.
 * @return A corresponding Complex object.
 */
function parseComplex(val) {
    var components;
    var order;
    if (val.indexOf('+') != -1) {
        components = val.split('+');
        components[1] = '+' + components[1];
    }
    else if (val.indexOf('-') != -1) {
        if (val.indexOf('-') == 0 && val.slice(1).indexOf('-') != -1) {
            components = val.slice(1).split('-');
            components[0] = '-' + components[0];
        }
        else {
            components = val.split('-');
        }
        components[1] = '-' + components[1];
    }
    else if (val.indexOf('j') == -1) {
        var real_1 = parseFloat(val);
        return new Complex(real_1 = real_1);
    }
    else {
        var imaginary_1 = parseFloat(val);
        return new Complex(imaginary_1 = imaginary_1);
    }
    order = Number(components[0].indexOf('j') != -1);
    var real = parseFloat(components[order]);
    var imaginary = parseFloat(components[Number(!order)].slice(0, components[Number(!order)].length - 1));
    return new Complex(real, imaginary);
}
exports.parseComplex = parseComplex;
